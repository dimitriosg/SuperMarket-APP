// packages/db/prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ---------------------------------------------------------
// NEW: Enums για καθαρά δεδομένα
// ---------------------------------------------------------
enum UnitType {
  KG
  G
  L
  ML
  ITEM // Τεμάχιο
}

model Chain {
  id        String   @id @default(cuid())
  slug      String   @unique
  label     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stores Store[]
}

model Store {
  id         String   @id @default(cuid())
  chainId    String
  externalId String
  name       String
  city       String?
  area       String?
  latitude   Float?
  longitude  Float?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  chain      Chain    @relation(fields: [chainId], references: [id])
  
  prices       PriceSnapshot[]
  productCodes StoreProductCode[]
  priceHistory PriceHistory[]

  @@unique([chainId, externalId])
  @@index([chainId])
}

model PriceHistory {
  id        String   @id @default(cuid())
  price     Decimal  @db.Decimal(10, 2) // Καλό είναι να ορίζουμε precision
  date      DateTime @default(now())
  
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  
  store     Store    @relation(fields: [storeId], references: [id])
  storeId   String

  @@index([productId, storeId, date])
}

// ---------------------------------------------------------
// REFACTORED: Product Model
// ---------------------------------------------------------
model Product {
  id             String   @id @default(cuid())
  ean            String   @unique
  name           String
  imageUrl       String?
  brand          String?
  
  // Display Quantity (π.χ. "6x330ml") - Το κρατάμε για το Frontend
  quantity       String? 

  // Normalised Quantity (π.χ. 1980, ML) - Για τους υπολογισμούς
  quantityValue  Float?
  quantityUnit   UnitType?
  
  normalizedName String @default("")
  embedding      Float[]?
  
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  prices       PriceSnapshot[]
  storeCodes   StoreProductCode[]
  priceHistory PriceHistory[]

  @@index([ean])
  @@index([name])
}

model StoreProductCode {
  id           String   @id @default(cuid())
  storeId      String
  productId    String
  externalCode String 

  store     Store    @relation(fields: [storeId], references: [id])
  product   Product  @relation(fields: [productId], references: [id])

  @@unique([storeId, externalCode])
  @@index([productId])
}

// ---------------------------------------------------------
// REFACTORED: PriceSnapshot Model
// ---------------------------------------------------------
model PriceSnapshot {
  id          String   @id @default(cuid())
  productId   String
  storeId     String
  price       Decimal  @db.Decimal(10, 2)
  promoPrice  Decimal? @db.Decimal(10, 2)
  inStock     Boolean  @default(true)
  
  // NEW: Flag για ύποπτες τιμές (Anomaly Detection)
  isAnomaly   Boolean  @default(false)
  
  collectedAt DateTime @default(now())

  product    Product  @relation(fields: [productId], references: [id])
  store      Store    @relation(fields: [storeId], references: [id])

  // Optimization: Συχνά θα ψάχνουμε την "τελευταία τιμή" για ένα προϊόν σε ένα κατάστημα
  @@index([productId, storeId, collectedAt(sort: Desc)])
  @@index([collectedAt])
}

// for AI suggestions
model AISuggestionsLog {
  id        String   @id @default(cuid())
  userId    String   @db.Uuid
  
  // Request data
  requestPayload    Json
  requestItemsCount Int
  requestBudget     Float?
  
  // Response data
  responsePayload   Json
  suggestionsCount  Int
  
  // Metadata
  modelUsed         String   // "gpt-5.2", "perplexity-sonar", "fallback-rule"
  latencyMs         Int
  aiTimeout         Boolean  @default(false)
  errorMessage      String?
  
  // Timestamps
  createdAt         DateTime @default(now())
  
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, aiTimeout])
}

model User {
  id           String   @id @default(uuid()) @db.Uuid
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
